{"version":3,"sources":["../../src/core/cache/FileCache.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\n\nimport { Cache } from \"./Cache\";\n\n/**\n * FileCache class implements the Cache interface.\n * It provides a file-based cache with TTL and size-based eviction strategies.\n */\nexport class FileCache implements Cache {\n  /**\n   * The directory where the cache files are stored.\n   * @type {string}\n   */\n  cacheDir;\n\n  /**\n   * The default lifespan of a cached item, in milliseconds.\n   * Cached items older than this value will be evicted.\n   * @type {number}\n   */\n  expiresIn = 24 * 60 * 60 * 1000; // 1 day in milliseconds\n\n  /**\n   * The maximum allowed size of the cache, in bytes.\n   * If the cache exceeds this size, some items will be evicted.\n   * @type {number}\n   */\n  maxCacheSize = 0.5 * 1024 * 1024 * 1024; // 0.5 GB\n\n  /**\n   * Constructor for the FileCache class.\n   * It creates the cache directory if it doesn't exist.\n   * @param {object} options - The options for the cache.\n   * @param {string} options.cacheDir - The directory where the cache files are stored.\n   * @param {number} options.expiresIn - The lifespan of a cached item, in milliseconds.\n   * @param {number} options.maxCacheSize - The maximum allowed size of the cache, in bytes.\n   */\n  constructor({\n    expiresIn = 24 * 60 * 60 * 1000, // 1 day in milliseconds\n    cacheDir = path.resolve(process.cwd(), \".cache\"), // Default cache directory is './cache'\n    maxCacheSize = 0.5 * 1024 * 1024 * 1024, // Default max cache size is 0.5 GB\n  } = {}) {\n    this.expiresIn = expiresIn;\n    this.cacheDir = cacheDir;\n    this.maxCacheSize = maxCacheSize;\n    if (!fs.existsSync(this.cacheDir)) {\n      fs.mkdirSync(this.cacheDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Hashes the key for a cache item.\n   * The key is an object with properties `functionType`, `functionId`, and `input`.\n   * The hash is used as the filename for the cache item.\n   * @param {object} key - The key for the cache item.\n   * @returns {string} The hash of the key.\n   */\n  private hashKey(key: {\n    functionType: string;\n    functionId?: string | undefined;\n    input: unknown;\n  }) {\n    const keyString = JSON.stringify(key);\n    const hash = crypto.createHash(\"sha256\");\n    hash.update(keyString);\n    return hash.digest(\"hex\");\n  }\n\n  /**\n   * Looks up a value in the cache.\n   * If the value is found and is not expired, it is returned.\n   * If the value is not found or is expired, null is returned.\n   * @param {object} key - The key for the cache item.\n   * @returns {Promise<object|null>} The cached value, or null if the value is not found or is expired.\n   */\n  async lookupValue(key: {\n    functionType: string;\n    functionId?: string | undefined;\n    input: unknown;\n  }): Promise<object | null> {\n    const filePath = path.join(this.cacheDir, this.hashKey(key));\n    return new Promise((resolve, reject) => {\n      fs.readFile(filePath, \"utf8\", (err, data) => {\n        if (err) {\n          if (err.code === \"ENOENT\") {\n            resolve(null); // File not found, resolve with null\n          } else {\n            reject(err); // Other error, reject promise\n          }\n        } else {\n          const parsedData = JSON.parse(data);\n          if (Date.now() - parsedData.time > this.expiresIn) {\n            // If the item is too old, delete the file and return a cache miss\n            fs.unlink(filePath, (err) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(null);\n              }\n            });\n          } else {\n            resolve(parsedData.value); // File found and not expired, resolve with data\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores a value in the cache.\n   * The value is stored with the current time, so it can be expired later.\n   * @param {object} key - The key for the cache item.\n   * @param {unknown} value - The value to store.\n   * @returns {Promise<void>}\n   */\n  async storeValue(\n    key: {\n      functionType: string;\n      functionId?: string | undefined;\n      input: unknown;\n    },\n    value: unknown\n  ): Promise<void> {\n    const filePath = path.join(this.cacheDir, this.hashKey(key));\n    const data = { value, time: Date.now() }; // Include the current time in the stored data\n    return new Promise((resolve, reject) => {\n      fs.writeFile(filePath, JSON.stringify(data), \"utf8\", (err) => {\n        if (err) {\n          reject(err); // Error writing file, reject promise\n        } else {\n          this.checkCacheSize().then(resolve).catch(reject); // Check the cache size after writing the file\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks the total size of the cache.\n   * If the cache is too large, it evicts the oldest items until the total cache size is within the limit.\n   *\n   * @returns {Promise<void>} A promise that resolves when the cache size check (and possible eviction) is complete.\n   */\n  private async checkCacheSize(): Promise<void> {\n    const files = await fs.promises.readdir(this.cacheDir);\n    let totalSize = 0;\n    const fileDetails: { file: string; stats: fs.Stats }[] = [];\n\n    // Get the size and stats for each file\n    for (const file of files) {\n      const stats = await fs.promises.stat(path.join(this.cacheDir, file));\n      totalSize += stats.size;\n      fileDetails.push({ file, stats });\n    }\n\n    // If the cache is too large, delete the oldest files until it's small enough\n    if (totalSize > this.maxCacheSize) {\n      // Sort the files by modification time, oldest first\n      fileDetails.sort(\n        (a, b) => a.stats.mtime.getTime() - b.stats.mtime.getTime()\n      );\n\n      // Delete files until the cache is small enough\n      for (const { file, stats } of fileDetails) {\n        if (totalSize <= this.maxCacheSize) {\n          break;\n        }\n        await fs.promises.unlink(path.join(this.cacheDir, file));\n        totalSize -= stats.size;\n      }\n    }\n  }\n}\n"],"mappings":"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","names":["resolve","err"]}