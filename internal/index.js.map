{"version":3,"sources":["../../src/core/api/retryNever.ts","../../src/core/api/throttleOff.ts","../../src/core/api/callWithRetryAndThrottle.ts","../../src/core/api/LoadAPIKeyError.ts","../../src/core/api/loadApiKey.ts","../../src/util/format/UInt8Utils.ts","../../src/util/format/DataContent.ts","../../src/core/schema/parseJSON.ts","../../src/util/getErrorMessage.ts","../../src/core/schema/JSONParseError.ts","../../src/core/schema/TypeValidationError.ts","../../src/core/schema/validateTypes.ts","../../src/core/api/ApiCallError.ts","../../src/core/api/postToApi.ts","../../src/core/executeFunctionCall.ts","../../src/core/FunctionEventSource.ts","../../src/core/ModelFusionConfiguration.ts","../../src/core/api/AbortError.ts","../../src/core/getFunctionCallLogger.ts","../../src/util/detectRuntime.ts","../../src/core/getRun.ts","../../src/util/DurationMeasurement.ts","../../src/util/runSafe.ts","../../src/model-function/AbstractModel.ts","../../src/util/streaming/convertReadableStreamToAsyncIterable.ts","../../src/util/streaming/EventSourceParserStream.ts","../../src/util/streaming/parseEventSourceStream.ts"],"sourcesContent":["/**\n * The `retryNever` strategy never retries a failed API call.\n */\nexport const retryNever =\n  () =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    f();\n","import { ThrottleFunction } from \"./ThrottleFunction\";\n\n/**\n * The `throttleOff` strategy does not limit parallel API calls.\n */\nexport const throttleOff = (): ThrottleFunction => (fn) => fn();\n","import { RetryFunction } from \"./RetryFunction\";\nimport { retryNever } from \"./retryNever\";\nimport { ThrottleFunction } from \"./ThrottleFunction\";\nimport { throttleOff } from \"./throttleOff\";\n\nexport const callWithRetryAndThrottle = async <OUTPUT>({\n  retry = retryNever(),\n  throttle = throttleOff(),\n  call,\n}: {\n  retry?: RetryFunction;\n  throttle?: ThrottleFunction;\n  call: () => PromiseLike<OUTPUT>;\n}): Promise<OUTPUT> => retry(async () => throttle(call));\n","export class LoadAPIKeyError extends Error {\n  constructor({ message }: { message: string }) {\n    super(message);\n\n    this.name = \"LoadAPIKeyError\";\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n}\n","import { LoadAPIKeyError } from \"./LoadAPIKeyError\";\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (apiKey != null) {\n    return apiKey;\n  }\n\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter into the API configuration. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter into the API configuration or set it as an environment variable named ${environmentVariableName}.`,\n    });\n  }\n\n  return apiKey;\n}\n","/*\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// copied from: https://github.com/sindresorhus/uint8array-extras/blob/main/index.js\n\nexport function base64ToUint8Array(base64String: string) {\n  return Uint8Array.from(\n    globalThis.atob(base64UrlToBase64(base64String)),\n    (x) => x.codePointAt(0)!\n  );\n}\n\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\n\nexport function uint8ArrayToBase64(array: Uint8Array) {\n  let base64;\n\n  if (array.length < MAX_BLOCK_SIZE) {\n    // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n    base64 = globalThis.btoa(String.fromCodePoint(...array));\n  } else {\n    base64 = \"\";\n    for (const value of array) {\n      base64 += String.fromCodePoint(value);\n    }\n\n    base64 = globalThis.btoa(base64);\n  }\n\n  return base64;\n}\n\nfunction base64UrlToBase64(base64url: string) {\n  return base64url.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n}\n","import { base64ToUint8Array, uint8ArrayToBase64 } from \"./UInt8Utils\";\n\n/**\n * Data content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return uint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return uint8ArrayToBase64(content);\n}\n\nexport function convertDataContentToUint8Array(\n  content: DataContent\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === \"string\") {\n    return base64ToUint8Array(content);\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new Error(\n    `Invalid data content. Expected a string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  );\n}\n","import SecureJSON from \"secure-json-parse\";\nimport { JSONParseError } from \"./JSONParseError\";\nimport { Schema } from \"./Schema\";\nimport { safeValidateTypes, validateTypes } from \"./validateTypes\";\nimport { TypeValidationError } from \"./TypeValidationError\";\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {unknown} - The parsed JSON object.\n */\nexport function parseJSON({ text }: { text: string }): unknown;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Schema<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: Schema<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: Schema<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      error instanceof JSONParseError ||\n      error instanceof TypeValidationError\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON({\n  text,\n}: {\n  text: string;\n}):\n  | { success: true; value: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Schema<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: Schema<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError };\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: Schema<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError } {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return {\n        success: true,\n        value: value as T,\n      };\n    }\n\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error:\n        error instanceof JSONParseError\n          ? error\n          : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n\n  if (typeof error === \"string\") {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { getErrorMessage } from \"../../util/getErrorMessage\";\n\nexport class JSONParseError extends Error {\n  // note: property order determines debugging output\n  readonly text: string;\n  readonly cause: unknown;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super(\n      `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`\n    );\n\n    this.name = \"JSONParseError\";\n\n    this.cause = cause;\n    this.text = text;\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      valueText: this.text,\n    };\n  }\n}\n","import { getErrorMessage } from \"../../util/getErrorMessage\";\n\nexport class TypeValidationError extends Error {\n  readonly value: unknown;\n  readonly cause: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super(\n      `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`\n    );\n\n    this.name = \"TypeValidationError\";\n\n    this.cause = cause;\n    this.value = value;\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      value: this.value,\n    };\n  }\n}\n","import { Schema } from \"./Schema\";\nimport { TypeValidationError } from \"./TypeValidationError\";\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Schema<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: Schema<T>;\n}): T {\n  try {\n    const validationResult = schema.validate(value);\n\n    if (!validationResult.success) {\n      throw new TypeValidationError({\n        value,\n        cause: validationResult.error,\n      });\n    }\n\n    return validationResult.value;\n  } catch (error) {\n    if (error instanceof TypeValidationError) {\n      throw error;\n    }\n\n    throw new TypeValidationError({ value, cause: error });\n  }\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Schema<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: Schema<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  try {\n    const validationResult = schema.validate(value);\n\n    if (validationResult.success) {\n      return validationResult;\n    }\n\n    return {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: validationResult.error,\n      }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error:\n        error instanceof TypeValidationError\n          ? error\n          : new TypeValidationError({ value, cause: error }),\n    };\n  }\n}\n","export class ApiCallError extends Error {\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n  readonly responseBody?: string;\n  readonly cause?: unknown;\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 429 || statusCode >= 500),\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super(message);\n\n    this.name = \"ApiCallError\";\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseBody = responseBody;\n    this.cause = cause;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data,\n    };\n  }\n}\n","import { convertDataContentToUint8Array } from \"../../util/format/DataContent\";\nimport { Schema } from \"../schema/Schema\";\nimport { parseJSON, safeParseJSON } from \"../schema/parseJSON\";\nimport { ApiCallError } from \"./ApiCallError\";\n\nexport type ResponseHandler<T> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<T>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: Schema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<ApiCallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === \"\") {\n      return new ApiCallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseBody,\n        isRetryable: isRetryable?.(response),\n      });\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return new ApiCallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable?.(response, parsedError),\n      });\n    } catch (parseError) {\n      return new ApiCallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseBody,\n        isRetryable: isRetryable?.(response),\n      });\n    }\n  };\n\nexport const createTextErrorResponseHandler =\n  ({\n    isRetryable,\n  }: {\n    isRetryable?: (response: Response) => boolean;\n  } = {}): ResponseHandler<ApiCallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    return new ApiCallError({\n      message: responseBody.trim() !== \"\" ? responseBody : response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseBody,\n      isRetryable: isRetryable?.(response),\n    });\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: Schema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    if (!parsedResult.success) {\n      throw new ApiCallError({\n        message: \"Invalid JSON response\",\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return parsedResult.value;\n  };\n\nexport const createTextResponseHandler =\n  (): ResponseHandler<string> =>\n  async ({ response }) =>\n    response.text();\n\nexport const createAudioMpegResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    if (response.headers.get(\"Content-Type\") !== \"audio/mpeg\") {\n      throw new ApiCallError({\n        message: \"Invalid Content-Type (must be audio/mpeg)\",\n        statusCode: response.status,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return convertDataContentToUint8Array(await response.arrayBuffer());\n  };\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n}: {\n  url: string;\n  headers?: Record<string, string>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<ApiCallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      ...headers,\n      \"Content-Type\": \"application/json\",\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n}: {\n  url: string;\n  headers?: Record<string, string>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    if (!response.ok) {\n      try {\n        throw await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (error instanceof Error) {\n          if (error.name === \"AbortError\" || error instanceof ApiCallError) {\n            throw error;\n          }\n        }\n\n        throw new ApiCallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          requestBodyValues: body.values,\n        });\n      }\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.name === \"AbortError\" || error instanceof ApiCallError) {\n          throw error;\n        }\n      }\n\n      throw new ApiCallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.name === \"AbortError\") {\n        throw error;\n      }\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new ApiCallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true,\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","import { nanoid as createId } from \"nanoid\";\nimport { FunctionEventSource } from \"./FunctionEventSource\";\nimport { FunctionCallOptions, FunctionOptions } from \"./FunctionOptions\";\nimport { getLogFormat } from \"./ModelFusionConfiguration\";\nimport { getFunctionObservers } from \"./ModelFusionConfiguration\";\nimport { AbortError } from \"./api/AbortError\";\nimport { getFunctionCallLogger } from \"./getFunctionCallLogger\";\nimport { getRun } from \"./getRun\";\nimport { startDurationMeasurement } from \"../util/DurationMeasurement\";\nimport { runSafe } from \"../util/runSafe\";\nimport { FunctionEvent } from \"./FunctionEvent\";\n\nexport async function executeFunctionCall<VALUE>({\n  options,\n  input,\n  functionType,\n  execute,\n  inputPropertyName = \"input\",\n  outputPropertyName = \"value\",\n}: {\n  options?: FunctionOptions;\n  input: unknown;\n  functionType: FunctionEvent[\"functionType\"];\n  execute: (options: FunctionCallOptions) => PromiseLike<VALUE>;\n  inputPropertyName?: string;\n  outputPropertyName?: string;\n}): Promise<VALUE> {\n  const run = await getRun(options?.run);\n\n  const eventSource = new FunctionEventSource({\n    observers: [\n      ...getFunctionCallLogger(options?.logging ?? getLogFormat()),\n      ...getFunctionObservers(),\n      ...(run?.functionObserver != null ? [run.functionObserver] : []),\n      ...(options?.observers ?? []),\n    ],\n    errorHandler: run?.errorHandler,\n  });\n\n  const durationMeasurement = startDurationMeasurement();\n\n  const startMetadata = {\n    functionType,\n\n    callId: `call-${createId()}`,\n    parentCallId: options?.callId,\n    runId: run?.runId,\n    sessionId: run?.sessionId,\n    userId: run?.userId,\n    functionId: options?.functionId,\n\n    [inputPropertyName]: input,\n\n    timestamp: durationMeasurement.startDate,\n    startTimestamp: durationMeasurement.startDate,\n  };\n\n  eventSource.notify({\n    eventType: \"started\",\n    ...startMetadata,\n  } as FunctionEvent);\n\n  const result = await runSafe(() =>\n    execute({\n      functionType,\n      functionId: options?.functionId,\n      callId: startMetadata.callId,\n      logging: options?.logging,\n      observers: options?.observers,\n      run,\n    })\n  );\n\n  const finishMetadata = {\n    eventType: \"finished\" as const,\n    ...startMetadata,\n    finishTimestamp: new Date(),\n    durationInMs: durationMeasurement.durationInMs,\n  };\n\n  if (!result.ok) {\n    if (result.isAborted) {\n      eventSource.notify({\n        ...finishMetadata,\n        eventType: \"finished\",\n        result: {\n          status: \"abort\",\n        },\n      } as FunctionEvent);\n      throw new AbortError();\n    }\n\n    eventSource.notify({\n      ...finishMetadata,\n      eventType: \"finished\",\n      result: {\n        status: \"error\",\n        error: result.error,\n      },\n    } as FunctionEvent);\n\n    throw result.error;\n  }\n\n  eventSource.notify({\n    ...finishMetadata,\n    eventType: \"finished\",\n    result: {\n      status: \"success\",\n      [outputPropertyName]: result.value,\n    },\n  } as FunctionEvent);\n\n  return result.value;\n}\n","import { ErrorHandler } from \"../util/ErrorHandler\";\nimport { FunctionEvent } from \"./FunctionEvent\";\nimport { FunctionObserver } from \"./FunctionObserver\";\n\nexport class FunctionEventSource {\n  readonly observers: FunctionObserver[];\n  readonly errorHandler: ErrorHandler;\n\n  constructor({\n    observers,\n    errorHandler,\n  }: {\n    observers: FunctionObserver[];\n    errorHandler?: ErrorHandler;\n  }) {\n    this.observers = observers;\n    this.errorHandler = errorHandler ?? ((error) => console.error(error));\n  }\n\n  notify(event: FunctionEvent) {\n    for (const observer of this.observers) {\n      try {\n        observer.onFunctionEvent(event);\n      } catch (error) {\n        this.errorHandler(error);\n      }\n    }\n  }\n}\n","import { FunctionObserver } from \"./FunctionObserver\";\nimport { LogFormat } from \"./LogFormat\";\n\nlet globalLogFormat: LogFormat = undefined;\nlet globalFunctionObservers: FunctionObserver[] = [];\n\nexport function setFunctionObservers(\n  functionObservers: FunctionObserver[]\n): void {\n  globalFunctionObservers = functionObservers;\n}\n\nexport function getFunctionObservers(): FunctionObserver[] {\n  return globalFunctionObservers;\n}\n\nexport function setLogFormat(format: LogFormat): void {\n  globalLogFormat = format;\n}\n\nexport function getLogFormat(): LogFormat {\n  return globalLogFormat;\n}\n","export class AbortError extends Error {\n  constructor(message = \"Aborted\") {\n    super(message);\n  }\n}\n","import { FunctionOptions } from \"./FunctionOptions\";\nimport { FunctionEvent } from \"./FunctionEvent\";\nimport { FunctionObserver } from \"./FunctionObserver\";\n\nexport function getFunctionCallLogger(\n  logging: FunctionOptions[\"logging\"]\n): Array<FunctionObserver> {\n  switch (logging) {\n    case \"basic-text\":\n      return [basicTextObserver];\n\n    case \"detailed-object\":\n      return [detailedObjectObserver];\n\n    case \"detailed-json\":\n      return [detailedJsonObserver];\n\n    case \"off\":\n    default:\n      return [];\n  }\n}\n\nconst basicTextObserver: FunctionObserver = {\n  onFunctionEvent(event: FunctionEvent) {\n    const text = `[${event.timestamp.toISOString()}] ${event.callId}${\n      event.functionId != null ? ` (${event.functionId})` : \"\"\n    } - ${event.functionType} ${event.eventType}`;\n\n    // log based on event type:\n    switch (event.eventType) {\n      case \"started\": {\n        console.log(text);\n        break;\n      }\n      case \"finished\": {\n        console.log(`${text} in ${event.durationInMs}ms`);\n        break;\n      }\n    }\n  },\n};\n\nconst detailedObjectObserver: FunctionObserver = {\n  onFunctionEvent(event: FunctionEvent) {\n    // Remove the \"response\" property from the result (if any):\n    if (\n      event.eventType === \"finished\" &&\n      event.result != null &&\n      \"rawResponse\" in event.result &&\n      event.result?.rawResponse != null\n    ) {\n      event = {\n        ...event,\n        result: Object.fromEntries(\n          Object.entries(event.result).filter(([k]) => k !== \"rawResponse\")\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any,\n      };\n    }\n\n    // filter all hard-to-read properties from event for cleaner console output:\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function cleanObject(obj: any): any {\n      if (obj instanceof Date || typeof obj === \"string\") {\n        return obj;\n      }\n\n      if (Array.isArray(obj)) {\n        return obj.map((item) => cleanObject(item));\n      }\n\n      if (obj !== null && typeof obj === \"object\") {\n        return Object.fromEntries(\n          Object.entries(obj)\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .map(([k, v]) => {\n              if (v === undefined) {\n                return [k, undefined];\n              } else if (v instanceof Uint8Array) {\n                return [k, \"omitted<Uint8Array>\"];\n              } else if (\n                Array.isArray(v) &&\n                v.length > 20 &&\n                v.every((v) => typeof v === \"number\")\n              ) {\n                return [k, \"omitted<Array<number>>\"];\n              } else {\n                return [k, cleanObject(v)];\n              }\n            })\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .filter(([_, v]) => v !== undefined)\n        );\n      }\n      return obj;\n    }\n\n    // Clean the event object\n    const cleanedEvent = cleanObject(event);\n\n    console.log(cleanedEvent);\n  },\n};\n\nconst detailedJsonObserver: FunctionObserver = {\n  onFunctionEvent(event: FunctionEvent) {\n    // Remove the \"response\" property from the result (if any):\n    if (\n      event.eventType === \"finished\" &&\n      event.result != null &&\n      \"rawResponse\" in event.result &&\n      event.result?.rawResponse != null\n    ) {\n      event = {\n        ...event,\n        result: Object.fromEntries(\n          Object.entries(event.result).filter(([k]) => k !== \"rawResponse\")\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) as any,\n      };\n    }\n\n    // filter all undefined properties from event for cleaner console output:\n    event = Object.fromEntries(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      Object.entries(event).filter(([_, v]) => v !== undefined)\n    ) as FunctionEvent;\n\n    console.log(JSON.stringify(event));\n  },\n};\n","export function detectRuntime() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalThisAny = globalThis as any;\n\n  if (globalThisAny.EdgeRuntime) {\n    return \"vercel-edge\";\n  }\n\n  if (globalThis.navigator?.userAgent === \"Cloudflare-Workers\") {\n    return \"cloudflare-workers\";\n  }\n\n  if (globalThis.process?.release?.name === \"node\") {\n    return \"node\";\n  }\n\n  if (globalThis.window) {\n    return \"browser\";\n  }\n\n  return null;\n}\n","import { detectRuntime } from \"../util/detectRuntime\";\nimport { Run } from \"./Run\";\n\ninterface RunStorage {\n  getStore: () => Run | undefined;\n  run: (context: Run, callback: () => void) => void;\n}\n\nlet runStorage: RunStorage | undefined;\n\nasync function ensureLoaded() {\n  if (detectRuntime() === \"node\" && !runStorage) {\n    // Note: using \"async_hooks\" instead of \"node:async_hooks\" to avoid webpack fallback problems.\n    // Note: we try both import and require to support both ESM and CJS.\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let AsyncLocalStorage: any;\n\n    try {\n      AsyncLocalStorage = (await import(\"async_hooks\")).AsyncLocalStorage;\n    } catch (error) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        AsyncLocalStorage = require(\"async_hooks\").AsyncLocalStorage;\n      } catch (error) {\n        throw new Error(`Failed to load 'async_hooks' module dynamically.`);\n      }\n    }\n\n    runStorage = new AsyncLocalStorage();\n  }\n\n  return Promise.resolve();\n}\n\n/**\n * Returns the run stored in an AsyncLocalStorage if running in Node.js. It can be set with `withRun()`.\n */\nexport async function getRun(run?: Run): Promise<Run | undefined> {\n  await ensureLoaded();\n  return run ?? runStorage?.getStore();\n}\n\n/**\n * Stores the run in an AsyncLocalStorage if running in Node.js. It can be retrieved with `getRun()`.\n */\nexport async function withRun(\n  run: Run,\n  callback: (run: Run) => PromiseLike<void>\n) {\n  await ensureLoaded();\n  if (runStorage != null) {\n    await runStorage.run(run, () => callback(run));\n  } else {\n    await callback(run);\n  }\n}\n","export function startDurationMeasurement(): DurationMeasurement {\n  // certain environments may not have the performance API:\n  return globalThis.performance != null\n    ? new PerformanceNowDurationMeasurement()\n    : new DateDurationMeasurement();\n}\n\nexport interface DurationMeasurement {\n  startEpochSeconds: number;\n  startDate: Date;\n  durationInMs: number;\n}\n\nclass PerformanceNowDurationMeasurement implements DurationMeasurement {\n  private readonly startTime = globalThis.performance.now();\n\n  get startEpochSeconds() {\n    return Math.floor(\n      (globalThis.performance.timeOrigin + this.startTime) / 1000\n    );\n  }\n\n  get startDate() {\n    return new Date(this.startEpochSeconds * 1000);\n  }\n\n  get durationInMs() {\n    return Math.ceil(globalThis.performance.now() - this.startTime);\n  }\n}\n\nclass DateDurationMeasurement implements DurationMeasurement {\n  private readonly startTime = Date.now();\n\n  get startEpochSeconds() {\n    return Math.floor(this.startTime / 1000);\n  }\n\n  get startDate() {\n    return new Date(this.startTime);\n  }\n\n  get durationInMs() {\n    return Date.now() - this.startTime;\n  }\n}\n","import { SafeResult } from \"./SafeResult\";\n\nexport const runSafe = async <OUTPUT>(\n  f: () => PromiseLike<OUTPUT>\n): Promise<SafeResult<OUTPUT>> => {\n  try {\n    return { ok: true, value: await f() };\n  } catch (error) {\n    if (error instanceof Error && error.name === \"AbortError\") {\n      return { ok: false, isAborted: true };\n    }\n\n    return { ok: false, error };\n  }\n};\n","import { ModelInformation } from \"./ModelInformation\";\nimport { Model, ModelSettings } from \"./Model\";\n\nexport abstract class AbstractModel<SETTINGS extends ModelSettings>\n  implements Model<SETTINGS>\n{\n  readonly settings: SETTINGS;\n\n  constructor({ settings }: { settings: SETTINGS }) {\n    this.settings = settings;\n  }\n\n  abstract readonly provider: string;\n  abstract readonly modelName: string | null;\n\n  // implemented as a separate accessor to remove all other properties from the model\n  get modelInformation(): ModelInformation {\n    return {\n      provider: this.provider,\n      modelName: this.modelName,\n    };\n  }\n\n  abstract get settingsForEvent(): Partial<SETTINGS>;\n\n  abstract withSettings(additionalSettings: Partial<SETTINGS>): this;\n}\n","export async function* convertReadableStreamToAsyncIterable<T>(\n  stream: ReadableStream<T>\n): AsyncIterable<T> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return; // This will close the generator\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n","import {\n  EventSourceParser,\n  ParsedEvent,\n  createParser,\n} from \"eventsource-parser\";\n\n/**\n * A TransformStream that ingests a stream of strings and produces a stream of ParsedEvents.\n *\n * @example\n * ```\n * const eventStream =\n *   response.body\n *     .pipeThrough(new TextDecoderStream())\n *     .pipeThrough(new EventSourceParserStream())\n * ```\n */\n// Copied from https://github.com/rexxars/eventsource-parser/blob/main/src/stream.ts to avoid issues with the commonjs build.\nexport class EventSourceParserStream extends TransformStream<\n  string,\n  ParsedEvent\n> {\n  constructor() {\n    let parser!: EventSourceParser;\n\n    super({\n      start(controller) {\n        parser = createParser((event) => {\n          if (event.type === \"event\") {\n            controller.enqueue(event);\n          }\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      },\n    });\n  }\n}\n","import { ParsedEvent } from \"eventsource-parser\";\nimport { convertReadableStreamToAsyncIterable } from \"./convertReadableStreamToAsyncIterable\";\nimport { EventSourceParserStream } from \"./EventSourceParserStream\";\n\nexport async function parseEventSourceStream({\n  stream,\n}: {\n  stream: ReadableStream<Uint8Array>;\n}): Promise<AsyncIterable<ParsedEvent>> {\n  const eventStream = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(new EventSourceParserStream());\n\n  return convertReadableStreamToAsyncIterable(eventStream);\n}\n"],"mappings":"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","names":["v","error"]}